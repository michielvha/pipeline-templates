# Reusable multi-stage template for building & releasing a Go application
# -----------------------------------------------------------------------
# HOW TO USE
# ----------
# stages:
# - template: pipelines/go-release-stages.yml@pipelineTemplates
#   parameters:
#     projectName: <YOUR_PROJECT>        # Required, everything else is optional
#     clean: false
#     goVersion: 1.24.3
#     goReleaserVersion: v2.10.1
#     owner: michielvh
#     dockerCondition: eq(variables['Build.SourceBranchName'], 'main')
#     poolName: default
#
# -----------------------------------------------------------------------

parameters:
# --------------------------------------------------
# Basic toggles
# --------------------------------------------------
- name: clean
  type: boolean
  default: false

# --------------------------------------------------
# Versions / naming
# --------------------------------------------------
- name: goVersion
  type: string
  default: '1.24.2'

- name: goReleaserVersion
  type: string
  default: 'v2.4.7'

- name: GolangciVersion
  type: string
  default: 'v2.1.6'

- name: goBin
  type: string
  default: '$(System.DefaultWorkingDirectory)/gobin'

- name: projectName
  type: string

- name: owner
  type: string
  default: 'michielvh'

# --------------------------------------------------
# Infrastructure
# --------------------------------------------------
- name: poolName
  type: string
  default: 'default'

# Whether the container stage should run (often only on "main")
- name: dockerCondition
  type: string
  default: "eq(variables['Build.SourceBranchName'], 'main')"

# Whether the linting should continue on failure
- name: AllowLintFailure
  type: boolean
  default: false

# ---------------------------------------------------------------------
#  STAGES
# ---------------------------------------------------------------------
stages:
# ─────────────────────────────────────────────────────────────────────
#  1) CODE QUALITY: Linting, Testing
# ─────────────────────────────────────────────────────────────────────
# TODO: Add testing using go test
- stage: Code_Quality
  displayName: "Lint and Test"
  pool: ${{ parameters.poolName }}

  jobs:
  - job: Linting
    displayName: "Lint codebase"
    variables:
      ProjectName: ${{ parameters.projectName }}
      GoVersion: ${{ parameters.goVersion }}
      GoBin: ${{ parameters.goBin }}

    steps:
    # -- checkout -----------------------------------------------------
    - checkout: self
      clean: ${{ parameters.clean }}
      fetchTags: true
      persistCredentials: true
      fetchDepth: 0

    # -- check for golangci-lint enabled -----------------------------
    - task: Bash@3
      displayName: "Check for golangci-lint config"
      inputs:
        targetType: inline
        script: |
          if [ -f ".golangci.yml" ]; then
            echo "Golangci-lint config found"
            echo "##vso[task.setvariable variable=GOLANGCI_LINT_ENABLED]true"
          else
            echo "No golangci-lint config found, skipping linting"
            echo "##vso[task.setvariable variable=GOLANGCI_LINT_ENABLED]false"
          fi

    # -- toolchain ----------------------------------------------------
    - task: GoTool@0
      displayName: "Install Go v$(GoVersion)"
      condition: eq(variables.GOLANGCI_LINT_ENABLED, 'true')
      inputs:
        version: '$(GoVersion)'
        goBin: '$(GoBin)'

    - task: Bash@3
      displayName: "Install golangci-lint"
      condition: eq(variables.GOLANGCI_LINT_ENABLED, 'true')
      inputs:
        targetType: inline
        script: |
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/HEAD/install.sh | sh -s -- -b $(GoBin) ${{ parameters.GolangciVersion }}
          echo '##vso[task.prependpath]$(GoBin)'

    - task: Bash@3
      displayName: "Run golangci-lint"
      condition: eq(variables.GOLANGCI_LINT_ENABLED, 'true')
      inputs:
        targetType: inline
        script: |
          golangci-lint run ./... --timeout=5m
      continueOnError: ${{ parameters.AllowLintFailure }}

# ─────────────────────────────────────────────────────────────────────
#  2) BUILD THE BINARY & PUBLISH ARTIFACTS
# ─────────────────────────────────────────────────────────────────────
- stage: Binary_Build_and_Publish
  displayName: "Build Binary"
  dependsOn:
  - Pre_Release
  - Code_Quality
  pool: ${{ parameters.poolName }}

  jobs:
  - job: Build_Binary
    displayName: "Build Binary"
    variables:
      # Define variables here so goreleaser can access them as environment variables
      ProjectName: ${{ parameters.projectName }}
      GoVersion: ${{ parameters.goVersion }}
      GoReleaserVersion: ${{ parameters.goReleaserVersion }}
      GoBin: ${{ parameters.goBin }}

    steps:
    # -- checkout -----------------------------------------------------
    - checkout: self
      clean: ${{ parameters.clean }}
      fetchTags: true
      persistCredentials: true
      fetchDepth: 0

    # -- toolchain ----------------------------------------------------
    - task: GoTool@0
      displayName: "Install Go v$(GoVersion)"
      inputs:
        version: '$(GoVersion)'
        goBin: '$(GoBin)'

    - task: Cache@2
      displayName: "Cache/Restore goreleaser $(GoReleaserVersion)"
      inputs:
        key: '"$(ProjectName)" | "$(Agent.OS) | "$(GoReleaserVersion)"'
        path: '$(GoBin)'
        cacheHitVar: 'CACHE_RESTORED'

    - task: JFrogGo@1
      displayName: "Install goreleaser ${{ parameters.goReleaserVersion }}"
      condition: ne(variables.CACHE_RESTORED, 'true')
      inputs:
        command: custom
        customCommand: install
        goArguments: 'github.com/goreleaser/goreleaser/v2@$(GoReleaserVersion)'
        artifactoryConnection: JFrog
        resolutionRepo: prd-go-virtual

    - task: Bash@3
      displayName: "Prepend GOBIN to PATH"
      inputs:
        targetType: inline
        script: |
          echo '##vso[task.prependpath]$(GOBIN)'
        workingDirectory: '$(System.DefaultWorkingDirectory)'

    # -- signing key --------------------------------------------------
    - task: DownloadSecureFile@1
      name: pgpprivatekey
      displayName: "Download PGP private key"
      inputs:
        secureFile: 'PGP PRIVATE KEY BLOCK.txt'

    - task: Bash@3
      displayName: "Import PGP key"
      inputs:
        targetType: inline
        script: |
          gpg --import '$(pgpprivatekey.secureFilePath)'

    # -- module proxy -------------------------------------------------
    - task: JfrogCliV2@1
      displayName: "Configure Artifactory for Go modules"
      inputs:
        jfrogPlatformConnection: 'CONNECTION TO ARTIFACTORY'
        command: jf go-config --server-id-resolve="1ba894ff-0587-466f-afaa-721bbc527d28" --repo-resolve="prd-go-virtual"

    # -- build --------------------------------------------------------
    - task: Bash@3
      displayName: "Build Go app"
      inputs:
        targetType: inline
        script: |
          echo "Building with version: $(Build.BuildNumber)"
          # Set environment variables for goreleaser
          export PROJECT_NAME="$(ProjectName)"
          goreleaser build --clean --snapshot
        workingDirectory: '$(System.DefaultWorkingDirectory)'

    # -- publish to Artifactory --------------------------------------
    - task: CopyFiles@2
      inputs:
        SourceFolder: dist
        Contents: '**'
        TargetFolder: '$(Build.ArtifactStagingDirectory)'
        CleanTargetFolder: true
        OverWrite: true
        retryCount: 5

    - task: JfrogCliV2@1
      displayName: "Upload Artifacts"
      inputs:
        jfrogPlatformConnection: 'JFrog Platform'
        command: jf rt u "$(Build.ArtifactStagingDirectory)/*" "prd-go-local/$(ProjectName)/$(Build.BuildNumber)/" --flat=true

    - task: JfrogCliV2@1
      displayName: "Collect Build Info"
      inputs:
        jfrogPlatformConnection: 'JFrog Platform'
        command: jf rt bp "$(Build.DefinitionName)" "$(Build.BuildNumber)"

    - task: JFrogPublishBuildInfo@1
      displayName: "Publish Build Info"
      inputs:
        artifactoryConnection: JFrog
        buildName: '$(Build.DefinitionName)'
        buildNumber: '$(Build.BuildNumber)'
        projectKey: prd


# ─────────────────────────────────────────────────────────────────────
#  3) BUILD & PUBLISH THE CONTAINER
# ─────────────────────────────────────────────────────────────────────
- stage: Container_Build_and_Publish
  displayName: "Build and Publish Docker Image"
  dependsOn: Binary_Build_and_Publish
  condition: ${{ parameters.dockerCondition }}
  pool: ${{ parameters.poolName }}

  jobs:
  - job: Build_Container
    displayName: "Build and Push Docker Image"
    variables:
      ProjectName: ${{ parameters.projectName }}

    steps:
    # -- download the binary we just produced ------------------------
    - task: JfrogCliV2@1
      displayName: "Download Artifact"
      inputs:
        jfrogPlatformConnection: 'JFrog Platform'
        command: |
          jf rt dl "prd-go-local/$(ProjectName)/$(Build.BuildNumber)/$(ProjectName)" "$(System.DefaultWorkingDirectory)/$(ProjectName)" --flat

    - task: Bash@3
      displayName: "Debug listing"
      inputs:
        targetType: inline
        script: |
          ls -al $(System.DefaultWorkingDirectory)/$(ProjectName)

    # -- Docker buildx / login --------------------------------------
    - task: Docker@2
      displayName: "Docker login"
      inputs:
        command: login
        containerRegistry: ContainerRegID

    - bash: |
        docker buildx inspect "${BUILDX_BUILDER}" || \
          docker buildx create --name "${BUILDX_BUILDER}" --driver remote tcp://buildkitd.alm.svc:1234
      displayName: "Setup buildx"

    # -- tag & push --------------------------------------------------
    - task: Bash@3
      displayName: "Tag image with BuildNumber"
      inputs:
        targetType: inline
        script: |
          imageTag=$(echo "$(Build.BuildNumber)" | tr '[:upper:]' '[:lower:]')
          echo "##vso[task.setvariable variable=imageTag]$imageTag"

    - task: Docker@2
      displayName: "Build & Push"
      inputs:
        command: build
        repository: "prd-docker-virtual/$(ProjectName)"
        tags: $(imageTag)
        dockerfile: '$(System.DefaultWorkingDirectory)/Dockerfile'
        buildContext: '$(System.DefaultWorkingDirectory)'
        arguments: |
          --build-arg IMAGE_NAME=$(ProjectName)
          --push
      env:
        BUILDX_NO_DEFAULT_ATTESTATIONS: 1

    # -- build-info & metadata --------------------------------------
    - task: JFrogPublishBuildInfo@1
      displayName: "Publish Build Info"
      inputs:
        artifactoryConnection: JFrog
        buildName: '$(Build.DefinitionName)'
        buildNumber: '$(Build.BuildNumber)'
        projectKey: prd